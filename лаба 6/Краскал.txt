#список ребер графа (вес, вершина 1, вершина 2)
R = [(17, 6, 1), (3, 6, 2), (5, 6, 3), (20, 6, 4), (8, 6, 5),
     (1, 1, 2), (40, 1, 5), (16, 2, 3), (2, 3, 4), (30, 4, 5)]

Rs = sorted(R, key = lambda x: x[0])
U = set() # список соединеных вершин
D = {} # словарь списка изолированных групп вершин
T = [] # список ребер остава

for r in Rs:
    if r[1] not in U or r[2] not in U: # проверка для исключения цикла в оставе
        if r[1] not in U and r[2] not in U: # если обе вершины не соед. то
            D[r[1]] = [r[1], r[2]] # формируем в словаре ключ с номерами вершин 
            D[r[2]] = D[r[1]] # и связываем их с одним и тем же списком вершин
        else:
            if not D.get(r[1]): # если в слвоаре нет первой вершины, то 
                D[r[2]].append(r[1]) # добавляем в список первую вершину
                D[r[1]] = D[r[2]] # и добавляем ключ с номером первой вершины
            else:
                D[r[1]].append(r[2]) # иначе делаем все тоже самое со второй вершиной
                D[r[2]] = D[r[1]]
                
        T.append(r)  # добавляем ребро в остов
        U.add(r[1])  # добавляем вершины в множ.U
        U.add(r[2])
        
for r in Rs:    # проходим по ребрам второй раз и объединяем разрозенные группы вершин
    if r[1] in D[r[1]] and r[2] not in D[r[1]]:     # если вершины принадлежат разным группам то объединяем
        T.append(r)     # добавляем ребро в остов
        gr1 = D[r[1]]
        D[r[1]] += D[r[2]]  # объединяем списки двух групп вершин
        D[r[2]] += gr1
        
print(T)
        